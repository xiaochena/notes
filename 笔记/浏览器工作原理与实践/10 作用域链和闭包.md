# 作用域链和闭包 ：代码中出现相同的变量，JavaScript 引擎是如何选择的？

在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。

```js
function bar() {
  console.log(myName);
}
function foo() {
  var myName = "极客邦";
  bar();
}
var myName = "极客时间";
foo();
```

![10 作用域链和闭包__2022-07-04-22-49-12](/attachments/10%20作用域链和闭包__2022-07-04-22-49-12.png)

在 JavaScript 执行过程中，其作用域链是由**词法作用域**决定的。

## 词法作用域

**词法作用域就是指作用域是由代码中函数声明的位置来决定的**，所以**词法作用域是静态的作用域**，通过它就能够预测代码在执行过程中如何查找标识符。
![10 作用域链和闭包__2022-07-04-22-50-57](/attachments/10%20作用域链和闭包__2022-07-04-22-50-57.png)
整个词法作用域链的顺序是：foo 函数作用域—>bar 函数作用域—>main 函数作用域—> 全局作用域。

**词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。**

## 闭包

```js
function foo() {
  var myName = "极客时间";
  let test1 = 1;
  const test2 = 2;
  var innerBar = {
    getName: function () {
      console.log(test1);
      return myName;
    },
    setName: function (newName) {
      myName = newName;
    },
  };
  return innerBar;
}
var bar = foo();
bar.setName("极客邦");
bar.getName();
console.log(bar.getName());
```

当执行到 foo 函数内部的 return innerBar 这行代码时调用栈的情况:
![10 作用域链和闭包__2022-07-04-22-57-33](/attachments/10%20作用域链和闭包__2022-07-04-22-57-33.png)

**根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量**

所以当 foo 函数执行完成之后，其整个调用栈的状态:
![10 作用域链和闭包__2022-07-04-22-59-46](/attachments/10%20作用域链和闭包__2022-07-04-22-59-46.png)

闭包产生
当执行到 bar.setName 方法中的 myName = "极客邦"这句代码时，JavaScript 引擎会沿着“当**前执行上下文–>foo 函数闭包–> 全局执行上下文**”的顺序来查找 myName 变量，

![10 作用域链和闭包__2022-07-04-23-00-43](/attachments/10%20作用域链和闭包__2022-07-04-23-00-43.png)
