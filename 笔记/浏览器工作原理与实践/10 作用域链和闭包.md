# 作用域链和闭包 ：代码中出现相同的变量，JavaScript 引擎是如何选择的？

在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。

```js
function bar() {
  console.log(myName);
}
function foo() {
  var myName = "极客邦";
  bar();
}
var myName = "极客时间";
foo();
```

![10 作用域链和闭包__2022-07-04-22-49-12](/attachments/10%20作用域链和闭包__2022-07-04-22-49-12.png)

在 JavaScript 执行过程中，其作用域链是由**词法作用域**决定的。

## 词法作用域

**词法作用域就是指作用域是由代码中函数声明的位置来决定的**，所以**词法作用域是静态的作用域**，通过它就能够预测代码在执行过程中如何查找标识符。
![10 作用域链和闭包__2022-07-04-22-50-57](/attachments/10%20作用域链和闭包__2022-07-04-22-50-57.png)
整个词法作用域链的顺序是：foo 函数作用域—>bar 函数作用域—>main 函数作用域—> 全局作用域。

**词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。**

## 闭包

```js
function foo() {
  var myName = "极客时间";
  let test1 = 1;
  const test2 = 2;
  var innerBar = {
    getName: function () {
      console.log(test1);
      return myName;
    },
    setName: function (newName) {
      myName = newName;
    },
  };
  return innerBar;
}
var bar = foo();
bar.setName("极客邦");
bar.getName();
console.log(bar.getName());
```

当执行到 foo 函数内部的 return innerBar 这行代码时调用栈的情况:
![10 作用域链和闭包__2022-07-04-22-57-33](/attachments/10%20作用域链和闭包__2022-07-04-22-57-33.png)

**根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量**虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。
![10 作用域链和闭包__2022-07-04-22-59-46](/attachments/10%20作用域链和闭包__2022-07-04-22-59-46.png)
这两个变量依然保存在内存中。像极了 setName 和 getName 方法背的一个专属背包，无论在哪里调用了 setName 和 getName 方法，它们都会背着这个 **foo 函数的专属背包。**
> 之所以是专属背包，是因为除了 setName 和 getName 函数之外，其他任何地方都是无法访问该背包的，我们就可以把这个背包称为 foo 函数的闭包。
闭包产生
当执行到 bar.setName 方法中的 myName = "极客邦"这句代码时，JavaScript 引擎会沿着“当**前执行上下文–>foo 函数闭包–> 全局执行上下文**”的顺序来查找 myName 变量。

我们终于可以给闭包一个正式的定义了。**在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。**


当执行到 bar.setName 方法中的myName = "极客邦"这句代码时JavaScript 引擎会**沿着“当前执行上下文–>foo 函数闭包–> 全局执行上下文”的顺序来查找 myName 变量。**
![10 作用域链和闭包__2022-07-04-23-00-43](/attachments/10%20作用域链和闭包__2022-07-04-23-00-43.png)

当调用 `bar.getName` 的时候，右边 `Scope` `项就体现出了作用域链的情况：Local` 就是当前的 `getName` 函数的作用域，`Closure(foo)` 是指 `foo` 函数的闭包，最下面的 `Global` 就是指全局作用域，**从“Local–>Closure(foo)–>Global”就是一个完整的作用域链。**
![10 作用域链和闭包-2023-09-17-14-18-17](/attachments/10%20作用域链和闭包-2023-09-17-14-18-17.png)

## 闭包是怎么回收的

如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

在使用闭包的时候，要尽量注意一个原则：**如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。**

## 闭包的优点和缺点
优点：
- **封装：** 闭包可以帮助保护你的代码，防止被外部环境修改。由于内部函数可以访问外部自己的局部变量，因此这些变量对于外部代码是不可访问的，这提供了一种封装数据的方式。
- **数据持久性：** 闭包可以维持或“记住”它们自己的词法环境，即使在其外层函数已经执行完毕后它们仍然可以访问这些环境。
- **动态函数创建：** 你可以使用闭包动态创建和返回函数。
- **模块化和私有状态：** 使用闭包，你可以创建私有变量，进而达到模块化的代码。

缺点：

- **内存消耗：** 因为闭包能访问自己的词法环境，这种环境必须持久保存在内存中，直到没人再引用它为止，这可能会带来额外的内存消耗。
- **调试困难：** 由于闭包的作用域链，如果你不小心写错了代码，可能会引入一些在调试时难以追踪的错误。
- **设计复杂** ：如果你过度使用闭包，可能会使代码变得难以理解和维护。