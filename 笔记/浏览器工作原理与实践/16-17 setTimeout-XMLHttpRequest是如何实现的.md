# 16 | WebAPI：setTimeout是如何实现的？

## setTimeout 的使用方式
```js
function showName(){
  console.log("极客时间")
}
var timerID = setTimeout(showName,200);
```
在 200 毫秒之后调用 showName 函数，并输出“极客时间”四个字。

## 浏览器怎么实现 setTimeout
要了解定时器的工作原理，就得先来回顾下之前讲的事件循环系统，我们知道渲染进程中**所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。**

- 当接收到 HTML 文档数据，渲染引擎就会将“解析 DOM”事件添加到消息队列中，
- 当用户改变了 Web 页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。
- 当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。
- 同样，如果要执行一段异步 JavaScript 代码，也是需要将执行任务添加到消息队列中。

以上列举的只是一小部分事件，**这些事件被添加到消息队列之后，事件循环系统就会按照消息队列中的顺序来执行事件。**

**因此要执行一段异步任务，需要先将任务添加到消息队列中。**

但消息队列中的任务是按照顺序执行的，而定时器需要在指定的时间间隔内被调用。所以**为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。**

在 Chrome 中除了正常使用的消息队列之外，还有另外一个**消息队列（延迟队列）**,包括了定时器和 Chromium 内部一些需要延迟执行的任务。

## 延迟队列的执行时机

**先从消息队列头部取出一个任务执行，该任务执行完后，Chrome 会去检查延迟队列，根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。**



# XMLHttpRequest 运作机制
具体工作过程:
![16-17 setTimeout-XMLHttpRequest是如何实现的-2023-12-17-14-40-15](/attachments/16-17%20setTimeout-XMLHttpRequest是如何实现的-2023-12-17-14-40-15.png)

## 补充阅读
### 1.如果当前任务执行时间过久，会影响定时器任务的执行、
```js
function bar() {
    console.log('bar')
}
function foo() {
    setTimeout(bar, 0);
    for (let i = 0; i < 5000; i++) {
        let i = 5+8+8+8
        console.log(i)
    }
}
foo()
```

尽管每次处理完消息队列中的一个任务之后，都会去检查并且执行延迟队列中的任务。但是如果当前任务执行时间过久，chrome没机会去检查，就会影响定时器任务的执行。

由于当前这段代码要执行 5000 次的 for 循环，所以当前这个任务的执行时间会比较久一点。这势必会影响到下个任务的执行时间。
![16 setTimeout是如何实现的-2023-12-17-13-49-16](/attachments/16%20setTimeout是如何实现的-2023-12-17-13-49-16.png)
### 2.如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒
### 3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒
未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。
### 4. 延时执行时间有最大值
Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。
```js
function showName(){
  console.log("极客时间")
}
var timerID = setTimeout(showName,2147483648); //会被理解调用执行
```